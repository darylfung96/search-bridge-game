import sun.awt.image.ImageWatched;

import java.util.LinkedList;

//TODO: print out the moves from the intiial state to the goal state after getting to the goal state

/*
*   State: Stores all the information of the current state everything is in.
*   for example:    If there are 4 people in the game.
*                   It will store these 4 people and their location in the game,
*                   either left or right side of the bridge.
*   args:
*           leftSide: All the people on the left side of the bridge.
*           rightSide: All the people on the right side of the bridge.
*           states: All the next states available in the queue.
*           torchLocation: The current torch position.
*           timeTaken: The total time taken to reach this state.
*
*           If torch position is on the left side, only players on the left side
*           is able to take an action to move to the other side of the bridge.
*
* */
public class State {

    private LinkedList<Integer> leftSide;
    private LinkedList<Integer> rightSide;
    private boolean isLeft; // this refers to the torch, if it is left this is true
    private int timeTaken;
    private int depth;
    //actions taken
    private LinkedList<String> actions;

    // used for heuristic
    private int highestSpeed;
    private int reward;

    public State(LinkedList<Integer> leftPeople, LinkedList<Integer> rightPeople,
                 boolean isLeft, int timeTaken, int depth) {
        leftSide = leftPeople;
        rightSide = rightPeople;
        this.isLeft = isLeft;
        this.timeTaken = timeTaken;
        this.depth = depth;
        actions = new LinkedList<>();
        this.highestSpeed=0;
    }

    // heuristic state constructor
    public State(LinkedList<Integer> leftPeople, LinkedList<Integer> rightPeople,
                 boolean isLeft, int timeTaken, int depth, int highestSpeed) {
        leftSide = leftPeople;
        rightSide = rightPeople;
        this.isLeft = isLeft;
        this.timeTaken = timeTaken;
        this.depth = depth;
        actions = new LinkedList<>();
        this.highestSpeed=highestSpeed;
    }

    /* setters */
    public void setReward(int reward) { this.reward = reward;}
    public void addActions(String action) { actions.add(action); }
    public void copyActions(State state) { this.actions = new LinkedList<>(state.getActions()); }

    /*
    *
        getNextAvailableStates return all the people that are able to move
        which means that the torch location is the same location as them

        example: If the torch location is on the left side, whoever is on the left side
                 is available to move.

        return: newStates
                The list of all the next available states.
    * */
    public LinkedList<State> getNextAvailableStates() {
        LinkedList<Integer> currentSide = new LinkedList<>();
        LinkedList<Integer> otherSide = new LinkedList<>();
        LinkedList<State> newStates = new LinkedList<>();
        if(isLeft) {
            if(leftSide != null) currentSide = new LinkedList<>(leftSide);
            if(rightSide != null) otherSide = new LinkedList<>(rightSide);
        } else {
            if (rightSide != null) currentSide = new LinkedList<>(rightSide);
            if (leftSide != null) otherSide = new LinkedList<>(leftSide);
        }

        // add one people to the other side of the bridge
        for (int index=0; index< currentSide.size(); index++) {
            LinkedList<Integer> newCurrentSide = new LinkedList<>(currentSide);
            LinkedList<Integer> newOtherSide = new LinkedList<>(otherSide);
            int firstPeopleMoved = newCurrentSide.remove(index);
            newOtherSide.add(firstPeopleMoved);
            State state = (isLeft) ? new State(newCurrentSide, newOtherSide, !isLeft,timeTaken+firstPeopleMoved, depth+1, highestSpeed) :
                    new State(newOtherSide, newCurrentSide, !isLeft, timeTaken+firstPeopleMoved, depth+1, highestSpeed);
            state.setReward(state.calculateReward(firstPeopleMoved));
            // set the action that get to this state
            String currentAction = "move " + firstPeopleMoved;
            currentAction += (isLeft) ?  " across" : " back";
            state.copyActions(this);    // copy all the previous actions from the parent
            state.addActions(currentAction); // add new action to state generated by parent
            // add to the new states of list
            newStates.add(state);
            // add two people to the other side of the bridge
            for (int second=0; second < newCurrentSide.size(); second++) {
                LinkedList<Integer> newSecondCurrentSide = new LinkedList<>(newCurrentSide);
                LinkedList<Integer> newSecondOtherSide = new LinkedList<>(newOtherSide);
                int secondPeopleMoved = newSecondCurrentSide.remove(second);
                newSecondOtherSide.add(secondPeopleMoved);
                int slowerSpeed = (firstPeopleMoved > secondPeopleMoved) ? firstPeopleMoved : secondPeopleMoved;
                state = (isLeft) ? new State(newSecondCurrentSide, newSecondOtherSide, !isLeft, timeTaken+slowerSpeed, depth+1, highestSpeed) :
                        new State(newSecondOtherSide, newSecondCurrentSide, !isLeft, timeTaken+slowerSpeed, depth+1, highestSpeed);
                state.setReward(state.calculateReward(firstPeopleMoved, secondPeopleMoved));
                // set the action that get to this state
                currentAction = "move "+ firstPeopleMoved + " " + secondPeopleMoved;
                currentAction += (isLeft) ? " across" : " back";
                state.copyActions(this);
                state.addActions(currentAction);
                // add to the new states of list
                newStates.add(state);
            }

        }


        return newStates;

    }

    // getters
    public LinkedList<Integer> getLeftSide() { return leftSide; }
    public LinkedList<Integer> getRightSide() { return rightSide; }
    public boolean isGoal() { return (leftSide == null || leftSide.size() == 0); }
    public boolean isLeft() { return isLeft; }
    public int getTimeTaken() { return timeTaken; }
    public int getDepth() { return depth; }
    public int getReward() { return reward; }
    public LinkedList<String> getActions() { return actions; }


    /*
    *   calculateReward
    *       Purpose:    Calculate the reward of the current state
    *       Calculation:    For every person on the right side of the bridge, reward + 10
    *                       The fastest person who move will have a better reward: reward = highestSpeed-currentPersonMoveSpeed
    *
    *       arguments:
    *                   person: The person who moved to achieve this state
    *
    *       return:     reward for this state
    *
    *
    * */
    private int calculateReward(int... person) {
        int reward = 0;
        for (int speed :getRightSide()) reward+=10;

        // if there is only one person
        if(person.length == 1) return reward+=highestSpeed-person[0];

        // Take the person with the highest time taken
        int speed = (person[0]>person[1]) ? person[0] : person[1];

        reward += highestSpeed-speed;
        return reward;
    }



    /* equal function */
    /*
    *   Equal State comparison function
    *
    *   We will define our own equal function here since for example:
    *   if
    *   left side: 1 2 3 4
    *   compare to
    *   left side: 2 1 3 4
    *
    *   They are both equal states but the built-in equal function is
    *   not able to find out that they are both equal.
    *
    *   Here the algorithm works as:
    *   We get the number of people on the side of the bridge * the speed of everyone on that side
    *
    *   example:
    *   1 2 3 4 => 2 * (1 + 2 + 3 + 4) = 20
    *   getSideInfo(String side) is a helper function that gets this information.
    *
    * */
    @Override
    public boolean equals(Object obj) {
        if(obj == null || obj.getClass() != getClass()) return false;

        State state = (State)obj;

        // if both side equals then we say this state is equivalent to the other state
        if(state.getSideInfo("left") == getSideInfo("left"))
            if(state.getSideInfo("right") == getSideInfo("right"))
                return true;

        return false;
    }



    private int getSideInfo(String side) {
        LinkedList<Integer> currentSide = (side.equals("left")) ? leftSide : rightSide;
        if(currentSide == null) return 0;

        int total = 0;
        final int EPSILON = 2;
        for (int index=0; index < currentSide.size(); index++) {
            total += currentSide.get(index) * Math.pow(EPSILON, index);
        }
        return total;
    }




    // print information
    public void printInfo() {
        printLeft();
        printRight();
        System.out.println("current depth: " + Integer.toString(depth));
        System.out.println("total crossing time: " + Integer.toString(timeTaken));
    }
    /*
    Private print helper functions
    * */
    private void printLeft() {
        System.out.println("left side:");
        if(leftSide != null) {
            for (int person : leftSide) System.out.print(Integer.toString(person) + " ");
            System.out.println();
        }
    }
    private void printRight() {
        System.out.println("right side:");
        if(rightSide != null) {
            for (int person : rightSide) System.out.print(Integer.toString(person) + " ");
            System.out.println();
        }
    }



}
